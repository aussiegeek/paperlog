import Papa from "papaparse";
import * as fs from "fs";
import prettier from "prettier";
import { camelCase, pascalCase } from "change-case";
import { assert, string } from "superstruct";

const enumTables = [
  {
    value: "Status",
    text: "Description",
    file: "qsl_rcvd",
  },
  {
    value: "Status",
    text: "Description",
    file: "qsl_sent",
  },
  {
    value: "Entity Code",
    text: "Entity Name",
    file: "dxcc_entity_code",
  },
  { value: "Abbreviation", text: "Continent", file: "continent" },
  { value: "Status", text: "Description", file: "qso_upload_status" },
  { value: "Abbreviation", text: "Meaning", file: "qso_complete" },
  { value: "Via", text: "Description", file: "qsl_via" },
  { value: "Abbreviation", text: "Meaning", file: "ant_path" },
  { value: "Enumeration", text: "Description", file: "propagation_mode" },
  { value: "Region Entity Code", text: "Region", file: "region" },
  { value: "Abbreviation", text: "Section Name", file: "arrl_section" },
  {
    value: "Code",
    text: "Primary Administrative Subdivision",
    file: "primary_administrative_subdivision",
  },
  {
    value: "Code",
    text: "Secondary Administrative Subdivision",
    file: "secondary_administrative_subdivision",
  },
  { value: "Credit For", text: "Award", file: "credit" },
  { value: "Sponsor", text: "Sponsoring Organization", file: "award_sponsor" },
  { value: "Mode", text: "Description", file: "mode" },
  { value: "Medium", text: "Description", file: "qsl_medium" },
];

function parseFile<T>(filename: string) {
  const data = fs.readFileSync(`${__dirname}/../adif_csv/${filename}`, "utf8");
  const result = Papa.parse<T>(data, { header: true, skipEmptyLines: true });
  if (result.errors.length > 0) {
    console.error("Error parsing file", filename, result.errors);
    process.exit(1);
  }
  return result;
}

function writeTypes(filename: string, contents: string) {
  try {
    const formatted = prettier.format(contents, { parser: "typescript" });
    fs.writeFileSync(`${__dirname}/../src/adif/${filename}`, formatted);
  } catch (e) {
    console.log(contents);
    console.error("Error writing file", filename, e);
    process.exit(1);
  }
}

function parseBands() {
  const result = parseFile<{
    "Enumeration Name": string;
    Band: string;
    "Lower Freq (MHz)": string;
    "Upper Freq (MHz)": string;
    "Import-only": string;
    Comments: string;
    "ADIF Version": string;
    "ADIF Status": string;
  }>("enumerations_band.csv");

  const bandData: Record<string, object> = {};

  result.data.forEach((data) => {
    const band = data["Band"];

    bandData[band] = {
      from: Number.parseFloat(data["Lower Freq (MHz)"]),
      to: Number.parseFloat(data["Upper Freq (MHz)"]),
    };

    const output = `
    // generated by scripts/adif_tables.ts
    import { enums, Infer, coerce, string } from "superstruct";

    export const bands = ${JSON.stringify(Object.keys(bandData))} as const;

    type BandRange = { [K in typeof bands[number]]: { from: number; to: number } };
    const bandData: BandRange = ${JSON.stringify(bandData)};

    export const BandEnum = coerce(enums(bands), string(), (value) =>
      value.toLowerCase()
    );
    export type BandEnum = Infer<typeof BandEnum>;
    export const bandRange: BandRange = bandData;
    `;
    writeTypes("bands.ts", output);
  });
}

function adifRecord() {
  const result = parseFile<{
    "Field Name": string;
    "Data Type": string;
    Enumeration: string;
    Description: string;
    "Header Field": string;
    "Minimum Value": string;
    "Maximum Value": string;
    "Import-only": string;
    Comments: string;
  }>("fields.csv");

  const fields: Record<
    string,
    { type: string; description: string; enumeration: string }
  > = {};
  result.data
    .filter((field) => field["Header Field"] != "Y")
    .filter((field) => field["Import-only"] == "")
    .forEach((data) => {
      fields[data["Field Name"]] = {
        type: data["Data Type"],
        description: data["Description"],
        enumeration: data["Enumeration"],
      };
    });

  const output = `
  // generated by scripts/adif_tables.ts
  import { optional, Describe, type } from "superstruct";
  import {
    Boolean,
    CreditList,
    Date,
    GridSquare,
    GridSquareList,
    Integer,
    IntlMultilineString,
    IntlString,
    IOTARefNo,
    Location,
    MultilineString,
    ModeEnum,
    Number,
    PositiveInteger,
    SecondarySubdivisionList,
    SponsoredAwardList,
    SOTARef,
    String,
    Time,
    WWFFRef,
  } from "./types";
  import { AntPathEnum } from "./antPath";
  import { ArrlSectionEnum } from "./arrlSection";
  import { BandEnum } from "./bands";
  import { ContinentEnum } from "./continent";
  import { DxccEntityCodeEnum } from "./dxccEntityCode";
  import { PrimaryAdministrativeSubdivisionEnum } from "./primaryAdministrativeSubdivision";
  import { PropagationModeEnum } from "./propagationMode";
  import { QslRcvdEnum } from "./qslRcvd";
  import { QslSentEnum } from "./qslSent";
  import { QslViaEnum } from "./qslVia";
  import { QsoCompleteEnum } from "./qsoComplete";
  import { QsoUploadStatusEnum } from "./qsoUploadStatus";
  import { RegionEnum } from "./region";
  import { SecondaryAdministrativeSubdivisionEnum } from "./secondaryAdministrativeSubdivision";
  import type Decimal from "decimal.js";

  export const adifRecordKeys = ${JSON.stringify(
    Object.keys(fields).map((k) => camelCase(k))
  )} as const;

  export interface AdifRecord extends Record<\`app\${string}\`, string|undefined> {
    ${Object.entries(fields)
      .reduce<string[]>((acc, [key, field]) => {
        const { description } = field;

        const mappedType = mapTSAdifType(key, field);
        const line = `${camelCase(key)}?: ${mappedType}|undefined;`;
        return [...acc, `// ${description}`, line];
      }, [])
      .join("\n")}
  };

  export const AdifRecord: Describe<AdifRecord> = type({
    ${Object.entries(fields)
      .reduce<string[]>((acc, [key, field]) => {
        const mappedType = mapSuperstructAdifType(key, field);
        const line = `${camelCase(key)}: ${mappedType},`;
        return [...acc, line];
      }, [])
      .join("\n")}
  });


  export const blankAdifRecord: AdifRecord = {${Object.keys(fields)
    .map((k) => `${camelCase(k)}: undefined`)
    .join(",\n")}};

  `;

  writeTypes("adifRecord.ts", output);

  const testArbsOutput = `
  // generated by scripts/adif_tables.ts
  import {
    ${[
      ...new Set(
        Object.entries(fields).map(([key, field]) => {
          const mappedType = typeForField(key, field);
          const line = `${camelCase(mappedType + "Arb")}`;
          return line;
        })
      ),
    ]
      .sort()
      .join(", ")}
    } from './adifFieldArbs';

  export const adifRecordArbs = {
    ${Object.entries(fields)
      .reduce<string[]>((acc, [key, field]) => {
        const mappedType = typeForField(key, field);
        const line = `${camelCase(key)}?: ${camelCase(mappedType + "Arb")},`;
        return [...acc, line];
      }, [])
      .join("\n")}
  };`;
  writeTypes("adifRecordArbs.ts", testArbsOutput);
}

function typeForField(
  key: string,
  {
    type,
    enumeration,
  }: {
    type: string;
    enumeration: string;
  }
) {
  switch (type) {
    case "Enumeration":
      switch (enumeration) {
        case "":
          return "String";
        case "Primary_Administrative_Subdivision[MY_DXCC]":
        case "Primary_Administrative_Subdivision[DXCC]":
          return "PrimaryAdministrativeSubdivisionEnum";
        case "Secondary_Administrative_Subdivision[DXCC]":
        case "Secondary_Administrative_Subdivision[MY_DXCC]":
          return "SecondaryAdministrativeSubdivisionEnum";
        default:
          return `${pascalCase(enumeration)}Enum`;
      }

    case "CreditList,AwardList":
      return "CreditList";

    // no name mapping required
    case "Boolean":
    case "Date":
    case "GridSquare":
    case "GridSquareList":
    case "IntlMultilineString":
    case "IntlString":
    case "IOTARefNo":
    case "Location":
    case "MultilineString":
    case "SecondarySubdivisionList":
    case "SOTARef":
    case "SponsoredAwardList":
    case "String":
    case "Time":
    case "WWFFRef":
    case "Integer":
    case "Number":
    case "PositiveInteger":
      return type;
    default:
      console.error(`Unknown type for field ${key}`, type);
      process.exit(1);
  }
}

function mapTSAdifType(
  key: string,
  {
    type,
    enumeration,
  }: {
    type: string;
    enumeration: string;
  }
) {
  const normalisedType = typeForField(key, { type, enumeration });

  switch (normalisedType) {
    // fallthrough to types defined in types.ts
    case "AntPathEnum":
    case "ArrlSectionEnum":
    case "BandEnum":
    case "ContinentEnum":
    case "CreditList":
    case "DxccEntityCodeEnum":
    case "ModeEnum":
    case "PrimaryAdministrativeSubdivisionEnum":
    case "PropagationModeEnum":
    case "QslRcvdEnum":
    case "QslSentEnum":
    case "QslViaEnum":
    case "QsoCompleteEnum":
    case "QsoUploadStatusEnum":
    case "RegionEnum":
    case "SecondaryAdministrativeSubdivisionEnum":
      return normalisedType;

    case "Boolean":
      return "boolean";

    case "Date":
    case "GridSquare":
    case "GridSquareList":
    case "IntlMultilineString":
    case "IntlString":
    case "IOTARefNo":
    case "Location":
    case "MultilineString":
    case "SecondarySubdivisionList":
    case "SOTARef":
    case "SponsoredAwardList":
    case "String":
    case "Time":
    case "WWFFRef":
      return "string";

    case "Number":
      return "Decimal";

    case "Integer":
    case "PositiveInteger":
      return "number";

    default:
      console.error(
        `Unknown typescript type for field ${key}`,
        type,
        normalisedType
      );
      process.exit(1);
  }
}

function mapSuperstructAdifType(
  key: string,
  {
    type,
    enumeration,
  }: {
    type: string;
    enumeration: string;
  }
) {
  const normalisedType = typeForField(key, { type, enumeration });

  return `optional(${normalisedType})`;
}

function genericEnumerationExtract(
  enumValueCol: string,
  enumTextCol: string,
  enum_name: string
) {
  const enumName = camelCase(enum_name);
  console.log("Generating", enumName);
  const result = parseFile<Record<string, string>>(
    `enumerations_${enum_name}.csv`
  );

  const enumData: Record<string, { description: string }> = {};

  result.data.forEach((data) => {
    const enumValue = data[enumValueCol];
    assert(enumValue, string());
    const description = data[enumTextCol];
    assert(description, string());

    enumData[enumValue] = { description };

    const output = `
  // generated by scripts/adif_tables.ts
  import { enums, Infer, coerce, string } from "superstruct";

  export const ${enumName} = [
    ${Object.entries(enumData)
      .reduce<string[]>((acc, [key, mode]) => {
        const description =
          mode.description.length > 0 ? `// ${mode.description}` : "";
        return [...acc, `"${key}", ${description}`];
      }, [])
      .join("\n")}
    ] as const;

  export const ${pascalCase(
    enumName
  )}Enum = coerce(enums(${enumName}), string(), (value) => {
    const foundValue = ${enumName}.find((v) => v.toUpperCase() == value.toUpperCase());

    return foundValue ?? value;
  });

  export type ${pascalCase(enumName)}Enum = Infer<typeof ${pascalCase(
      enumName
    )}Enum>;
  `;

    writeTypes(`${enumName}.ts`, output);
  });
}

parseBands();
adifRecord();

enumTables.forEach(({ value, text, file }) => {
  if (process.env["SKIP_ENUM"]) {
    console.log("Skiping ", file);
  } else {
    genericEnumerationExtract(value, text, file);
  }
});
