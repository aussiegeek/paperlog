import Papa from "papaparse";
import * as fs from "fs";
import prettier from "prettier";
import { camelCase } from "camel-case";

function parseFile<T>(filename: string) {
  const data = fs.readFileSync(`${__dirname}/../adif_csv/${filename}`, "utf8");
  const result = Papa.parse<T>(data, { header: true, skipEmptyLines: true });
  if (result.errors.length > 0) {
    console.error("Error parsing file", filename, result.errors);
    process.exit(1);
  }
  return result;
}

function writeTypes(filename: string, contents: string) {
  try {
    const formatted = prettier.format(contents, { parser: "typescript" });
    fs.writeFileSync(`${__dirname}/../src/adif/${filename}`, formatted);
  } catch (e) {
    console.log(contents);
    console.error("Error writing file", filename, e);
    process.exit(1);
  }
}

function parseBands() {
  const result = parseFile<{
    "Enumeration Name": string;
    Band: string;
    "Lower Freq (MHz)": string;
    "Upper Freq (MHz)": string;
    "Import-only": string;
    Comments: string;
    "ADIF Version": string;
    "ADIF Status": string;
  }>("enumerations_band.csv");

  const bandData: Record<string, object> = {};

  result.data.forEach((data) => {
    const band = data["Band"];

    bandData[band] = {
      from: Number.parseFloat(data["Lower Freq (MHz)"]),
      to: Number.parseFloat(data["Upper Freq (MHz)"]),
    };

    const output = `
    // generated by scripts/adif_tables.ts
    import { enums } from "superstruct";

    export const bands = ${JSON.stringify(Object.keys(bandData))} as const;

    type BandRange = { [K in typeof bands[number]]: { from: number; to: number } };
    const bandData: BandRange = ${JSON.stringify(bandData)};

    export const BandEnum = enums(bands);

    export const bandRange: BandRange = bandData;
    `;
    writeTypes("bands.ts", output);
  });
}

function adifRecord() {
  const result = parseFile<{
    "Field Name": string;
    "Data Type": string;
    Enumeration: string;
    Description: string;
    "Header Field": string;
    "Minimum Value": string;
    "Maximum Value": string;
    "Import-only": string;
    Comments: string;
  }>("fields.csv");

  const fieldsFilter = [
    "STATION_CALLSIGN",
    "QSO_DATE",
    "TIME_ON",
    "CALL",
    "BAND",
    "MODE",
    "SUBMODE",
    "FREQ",
    "RST_SENT",
    "RST_RCVD",
    "SOTA_REF",
    "MY_SOTA_REF",
    "SIG",
    "SIG_INFO",
    "MY_SIG",
    "MY_SIG_INFO",
  ];

  const fields: Record<
    string,
    { type: string; description: string; enumeration: string }
  > = {};
  result.data
    .filter((field) => field["Header Field"] != "Y")
    .forEach((data) => {
      fields[data["Field Name"]] = {
        type: data["Data Type"],
        description: data["Description"],
        enumeration: data["Enumeration"],
      };
    });

  const output = `
  // generated by scripts/adif_tables.ts
  import { optional, string, number, Infer, object } from "superstruct";
  import { AdifTime, AdifDate } from "./types";
  import { BandEnum } from "./bands";
  import { ModeEnum } from "./modes";

  export const AdifRecord = object({
    ${Object.entries(fields)
      .reduce<string[]>((acc, [key, field]) => {
        const { type, description } = field;
        const commented = fieldsFilter.includes(key) ? "" : "// ";

        const mappedType = fieldsFilter.includes(key)
          ? mapAdifType(field)
          : type;
        const line = `${commented}${camelCase(key)}: ${mappedType},`;
        return [...acc, `// ${description}`, line, ""];
      }, [])
      .join("\n")}
  });

  export type AdifRecord = Infer<typeof AdifRecord>;

  `;

  writeTypes("adifRecord.ts", output);
}

function mapAdifType({
  type,
  enumeration,
}: {
  type: string;
  enumeration: string;
}) {
  switch (type) {
    case "String":
    case "SOTARef":
      return "optional(string())";
    case "Date":
      return "AdifDate";
    case "Time":
      return "AdifTime";
    case "Enumeration":
      return enumeration + "Enum";
    case "Number":
      return "optional(number())";
    default:
      console.error("Unknown type", type);
      process.exit(1);
  }
}

function parseModes() {
  const result = parseFile<{
    Mode: string;
    Submodes: string;
    Description: string;
  }>("enumerations_mode.csv");

  const modeData: Record<string, { description: string }> = {};

  result.data.forEach((data) => {
    const mode = data["Mode"];

    modeData[mode] = {
      description: data["Description"],
    };

    const output = `
    // generated by scripts/adif_tables.ts
    import { enums } from "superstruct";

    export const modes = [
      ${Object.entries(modeData)
        .reduce<string[]>((acc, [key, mode]) => {
          const description =
            mode.description.length > 0 ? `// ${mode.description}` : "";
          return [...acc, `"${key}", ${description}`];
        }, [])
        .join("\n")}
      ] as const;




    export const ModeEnum = enums(modes);

    `;
    writeTypes("modes.ts", output);
  });
}

parseBands();
adifRecord();
parseModes();
